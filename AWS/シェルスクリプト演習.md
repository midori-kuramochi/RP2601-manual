# シェルスクリプト演習

### ■Shell-1

下記ファイルをバックアップするシェルを作成せよ
- バックアップ先のファイル名はhttpd.conf.202201011212.bakといった、年月日時分秒のフォーマットで作成すること
- バックアップ元とバックアップ先ディレクトリは変数で定義すること

バックアップ元：/etc/httpd/conf/httpd.conf
バックアップ先：/home/ec2-user/自分の名前/backup/

<code> # vi backup.sh </code> 

- バックアップ元とバックアップ先ディレクトリは変数で定義すること
  →変数定義が必要
  >ORIGINAL_FILE=/etc/httpd/conf/httpd.conf
  BACKUP_FILE=/home/ec2-user/midori-kuramochi/backup/

- バックアップ先のファイル名はhttpd.conf.202201011212.bakといった、年月日時分秒のフォーマットで作成すること
  →`date +%Y%m%d%H%M%S`で定義が必要
  
  httpd.conf.202201011212.bak
  　→httpd.conf.{`date +%Y%m%d%H%M%S`}.bak
  　　→DATE=`date +%Y%m%d%H%M%S`

```
#!/bin/bash

# バックアップ元ファイル
ORIGINAL_FILE="/etc/httpd/conf/httpd.conf"

# バックアップ先ディレクトリ
BACKUP_DIR="/home/ec2-user/midori-kuramochi/backup"

# 日付（年月日時分秒）
DATE=$(date +%Y%m%d%H%M%S)

# バックアップ実行
cp "$ORIGINAL_FILE" "$BACKUP_DIR/httpd.conf.$DATE.bak"
```
---

### ■Shell-2

シェルスクリプト演習1で作成したシェルに汎用性をもたせてください。
具体的には下記を実装する。
・１つ目の引数で、バックアップ元のファイルを指定
・２つ目の引数で、バックアップ先のディレクトリを指定
上記実装した上で、バックアップ元を/etc/named.confでバックアップできればOK

vi backup2.sh

・１つ目の引数で、バックアップ元のファイルを指定
・２つ目の引数で、バックアップ先のディレクトリを指定
  → sh backup2.sh `$1`(バックアップ元のファイル) `$2`（バックアップ先のディレクトリ）
```
#!/bin/bash

#引数チェック
if [ $# -ne 2 ]
then
       echo "Usage: $0 <backup_source_file> <backup_destination_dir>"
       exit 1
fi

#引数
ORIGINAL_FILE="$1"
BACKUP_DIR="$2"

#日付（年月日時分秒）
DATE=`date +%Y%m%d%H%M%S`

#元ファイル名だけを取得
FILENAME=`basename "$ORIGINAL_FILE"`

#バックアップ実行
cp "$ORIGINAL_FILE" "$BACKUP_DIR/$FILENAME.$DATE.bak"
```
---

### ■Shell-3

シェルスクリプト演習2で作成したスクリプトを、引数を使わずに対話形式で実装してください

例）
バックアップ元は？  xxxxx
バックアップ先は? xxxx
xxxxをバックアップしました。

[考え方]
- 対話形式
  →readコマンドを使うんだな！

```
#!/bin/bash
echo "バックアップ元のファイルは？（絶対パスで指定）"
read ORIGINAL_FILE
echo "バックアップ先のディレクトリは?（絶対パスで指定）"
read BACKUP_DIR

# 入力チェック
if [ ! -f "$ORIGINAL_FILE" ]; then
       echo "エラー：バックアップ元ファイルが存在しません"
       exit 1
fi

if [ ! -d "$BACKUP_DIR" ]; then
       echo "エラー：バックアップ先ディレクトリが存在しません"
       exit 1
fi

# 日付（年月日時分秒）
DATE=`date +%Y%m%d%H%M%S`

# 元ファイル名だけを取得
FILENAME=`basename "$ORIGINAL_FILE"`

# バックアップ実行
cp "$ORIGINAL_FILE" "$BACKUP_DIR/$FILENAME.$DATE.bak"

# 完了メッセージ
echo "$ORIGINAL_FILE をバックアップしました。"
```

### ■Shell-4

下記2つの要件を満たすシェルを書いてみてください。
・backup.listファイルに記載されたファイル名をバックアップしてくれる仕組み
・バックアップしたファイルがちゃんと存在するかチェックする仕組み
引数と対話形式は今回使わない。シェルを引数無しで実行し、上記が実行されること

[考え方]
backup.listの中身の読み込みが必要
→ [ -r backup.listの中身 ]
→ 1行ずつ読み込みたい！
→ IFS = Internal Field Separator（区切り文字）


```
#!/bin/bash

# 設定
LIST_FILE="./backup.list"
BACKUP_DIR="/home/ec2-user/midori-kuramochi/backup"
DATE=`date +%Y%m%d%H%M%S`

# backup.list があるか確認
if [ ! -f "$LIST_FILE" ]
then
       echo "エラー：backup.list がありません"
       exit 1
fi

# バックアップ先ディレクトリがあるか確認
if [ ! -d "$BACKUP_DIR" ]
then
        echo "エラー：バックアップ先ディレクトリがありません"
        exit 1
fi

# backup.list を1行ずつ読む
while IFS= read -r ORIGINAL_FILE
do

  # 空行は何もしない
  if [ -z "$ORIGINAL_FILE" ]
  then
    continue
  fi

  # 元ファイルがあるか確認
  if [ ! -f "$ORIGINAL_FILE" ]
  then
    echo "スキップ：ファイルがありません -> $ORIGINAL_FILE"
    continue
  fi

  # 保存先ファイル名を作る
  FILENAME=$(basename "$ORIGINAL_FILE")
  DEST_FILE="$BACKUP_DIR/$FILENAME.$DATE.bak"

  # バックアップする
  cp "$ORIGINAL_FILE" "$DEST_FILE"

  # バックアップできたか確認
  if [ -f "$DEST_FILE" ]
  then
    echo "OK：$ORIGINAL_FILE をバックアップしました"
  else
    echo "NG：バックアップに失敗しました -> $ORIGINAL_FILE"
  fi

done < "$LIST_FILE"
```


<模範解答>
・backup.listファイルに記載されたファイル名をバックアップしてくれる仕組み
→ cp 
・バックアップしたファイルがちゃんと存在するかチェックする仕組み
引数と対話形式は今回使わない。シェルを引数無しで実行し、上記が実行されること

[考え方]
backup.listの中身の読み込みが必要
→ cat backup.list
→ 1行ずつ読み込みたい！
→ IFS = Internal Field Separator（区切り文字）


### ■Shell-6
下記コマンドを使って 3～4サイトを監視するスクリプトを作成してください
curl -LI 監視したいURL -o /dev/null -w '%{http_code}\n' -s

・ifとforを使うこと
・監視するサイトはsite.listというファイルを使ってシェルから読み込むこと
・監視結果があとで見られるようにログを出力する機能をつけてください

・監視するサイトはsite.listというファイルを使ってシェルから読み込むこと

[考え方]



```
#!/bin/bash

# 設定
LIST_FILE="./site.list"
LOG_FILE="/home/ec2-user/midori-kuramochi/site.log"

# site.list があるか確認
if [ ! -f "$LIST_FILE" ]; then
  echo "エラー：site.list がありません"
  exit 1
fi

# site.list を読み込んで配列に入れる
SITES=()
while IFS= read -r URL; 
do
  # 空行はスキップ
  if [ -z "$URL" ]; then
    continue
  fi
  SITES+=("$URL")
done < "$LIST_FILE"

# 監視対象が0件なら終了
if [ ${#SITES[@]} -eq 0 ]; 
then
  echo "エラー：監視対象URLがありません（$LIST_FILE が空です）"
  exit 1
fi

# ログ開始行（ここで時刻を取る）
echo "===== CHECK START $(date '+%Y-%m-%d %H:%M:%S') =====" >> "$LOG_FILE"

# 監視（forを使う）
for URL in "${SITES[@]}"; 
do
  DATE=$(date '+%Y-%m-%d %H:%M:%S')
  STATUS=$(curl -LI "$URL" -o /dev/null -w '%{http_code}' -s)

  # ステータス確認
  if [ "$STATUS" = "200" ]; 
  then
    RESULT="OK"
    echo "正常に稼働しています。"
  else
    RESULT="NG"
    echo "異常検知：HTTP $STATUS"
  fi

  # ログ出力（あとで見られる）
  echo "$DATE $RESULT $URL HTTP=$STATUS" >> "$LOG_FILE"
done

# ログ終了行（ここで時刻を取る）
echo "===== CHECK END   $(date '+%Y-%m-%d %H:%M:%S') =====" >> "$LOG_FILE"

```
---